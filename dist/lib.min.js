'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var datocmsClient = require('datocms-client');

async function exportModels ({ apiKey }) {
  const client = new datocmsClient.SiteClient(apiKey);
  const itemTypes = await client.itemTypes.all();
  const fields = await Promise.all(itemTypes.map(async (itemType) => client.fields.all(itemType.id)));
  return {
    itemTypes,
    fields: fields.flat(),
  };
}

async function importModels ({ apiKey, data }) {
  const client = new datocmsClient.SiteClient(apiKey);
  let existingItemTypes = [];
  let existingFields = [];
  const { itemTypes, fields } = data;

  existingItemTypes = await client.itemTypes.all();

  const getPropsFromItemType = function getPropsFromItemType(itemType) {
    const {
      // eslint-disable-next-line no-shadow
      id, singletonItem, fields, titleField, orderingField, ...itemTypeProps
    } = itemType;
    return itemTypeProps;
  };

  const getPropsFromField = function getPropsFromField(field) {
    const {
      id, position, itemType, ...fieldProps
    } = field;
    return fieldProps;
  };

  const mapOldItemTypeIDToNewItemTypeID = (id) => {
    const oldItemType = itemTypes.find((i) => i.id === id);
    const existingItemType = existingItemTypes.find((i) => i.apiKey === oldItemType.apiKey);
    return existingItemType.id;
  };

  const mapOldFieldIDToNewFieldID = (id, existingItemType) => {
    const oldExistingField = fields.find((f) => f.id === id);
    const existingField = existingFields.find((i) => i.apiKey === oldExistingField.apiKey && i.itemType === existingItemType.id);
    return existingField.id;
  };

  // get all existing fields
  await Promise.all(existingItemTypes.map(async (itemType) => {
    const existingFieldsOfItemType = await client.fields.all(itemType.id);
    existingFields = [...existingFields, ...existingFieldsOfItemType];
  }));

  // make sure all itemTypes exist and are updated
  await Promise.all(itemTypes.map(async (itemType) => {
    const existingItemType = existingItemTypes.find((i) => i.apiKey === itemType.apiKey);
    let currentItemType = existingItemType || itemType;
    const itemTypeProps = getPropsFromItemType(itemType);

    // check if itemType already exists in project, if so update it, else create it
    if (existingItemType) {
      console.info(`itemType ${currentItemType.apiKey} already exists, updating...`);
      currentItemType = await client.itemTypes.update(currentItemType.id, itemTypeProps);
    } else {
      console.info(`itemType ${currentItemType.apiKey} doesn't exist, creating...`);
      currentItemType = await client.itemTypes.create(itemTypeProps);
    }

    existingItemTypes = [...existingItemTypes, currentItemType];
  }));

  // find fields that depend on other fields and put them last so
  // the other fields already exist before we deal with those
  const dependingFieldsFilter = (i) => i.fieldType !== 'slug';
  const defaultFields = fields.filter(dependingFieldsFilter);
  const dependingFields = fields.filter((i) => !dependingFieldsFilter(i));
  const sortedFields = [...defaultFields, ...dependingFields];

  for (const field of sortedFields) {
    const oldItemTypeOfField = itemTypes.find((i) => i.id === field.itemType);
    const existingItemTypeOfField = existingItemTypes.find((i) => i.apiKey === oldItemTypeOfField.apiKey);
    const fieldProps = getPropsFromField(field);
    const existingField = existingFields.find((f) => f.apiKey === field.apiKey && f.itemType === existingItemTypeOfField.id);
    let currentField = existingField || field;

    if (
      field.validators
      && field.validators.richTextBlocks
      && field.validators.richTextBlocks.itemTypes
    ) {
      fieldProps.validators = { richTextBlocks: {} };
      fieldProps.validators.richTextBlocks.itemTypes = field.validators.richTextBlocks.itemTypes.map(mapOldItemTypeIDToNewItemTypeID);
    }

    if (
      field.validators
      && field.validators.itemsItemType
      && field.validators.itemsItemType.itemTypes
    ) {
      fieldProps.validators = { itemsItemType: {} };
      fieldProps.validators.itemsItemType.itemTypes = field.validators.itemsItemType.itemTypes.map(mapOldItemTypeIDToNewItemTypeID);
    }

    if (
      field.validators
      && field.validators.itemItemType
      && field.validators.itemItemType.itemTypes
    ) {
      fieldProps.validators = { itemItemType: {} };
      fieldProps.validators.itemItemType.itemTypes = field.validators.itemItemType.itemTypes.map(mapOldItemTypeIDToNewItemTypeID);
    }

    if (
      field.validators
      && field.validators.slugTitleField
      && field.validators.slugTitleField.titleFieldId
    ) {
      fieldProps.validators = { ...field.validators };
      fieldProps.validators.slugTitleField = { titleFieldId: '' };
      fieldProps.validators.slugTitleField.titleFieldId = mapOldFieldIDToNewFieldID(field.validators.slugTitleField.titleFieldId, existingItemTypeOfField);
    }

    if (existingField) {
      console.info(`field ${currentField.apiKey} already exists, updating ...`);
      currentField = await client.fields.update(existingField.id, fieldProps);
      existingFields = existingFields.map((f) => (f.id === currentField.id ? currentField : f));
    } else {
      console.info(`field ${currentField.apiKey} doesn't exist, creating ...`);
      currentField = await client.fields.create(existingItemTypeOfField.id, fieldProps);
      existingFields = [...existingFields, currentField];
    }
  }

  // resolve itemType props that depend on fields
  for (const itemType of itemTypes) {
    let newTitleField;
    let newOrderingField;
    const existingItemType = existingItemTypes.find((i) => i.apiKey === itemType.apiKey);

    if (itemType.titleField) {
      // eslint-disable-next-line max-len
      const oldApiKeyOfTitleField = fields.find((f) => f.id === itemType.titleField).apiKey;
      newTitleField = existingFields.find((f) => f.apiKey === oldApiKeyOfTitleField).id;
    }

    if (itemType.orderingField) {
      // eslint-disable-next-line max-len
      const oldApiKeyOfOrderingFIeld = fields.find((f) => f.id === itemType.orderingField).apiKey;
      newOrderingField = existingFields.find((f) => f.apiKey === oldApiKeyOfOrderingFIeld).id;
    }

    const updateData = {
      ...getPropsFromItemType(existingItemType),
      titleField: newTitleField,
      orderingField: newOrderingField,
    };

    await client.itemTypes.update(existingItemType.id, updateData);
  }
}

async function exportMenu ({ apiKey }) {
  const client = new datocmsClient.SiteClient(apiKey);
  return client.menuItems.all();
}

async function importMenu ({ apiKey, menuItems, models }) {
  const client = new datocmsClient.SiteClient(apiKey);
  const existingItemTypes = await client.itemTypes.all();
  let existingMenuItems = await client.menuItems.all();

  const getPropsOfMenuItem = (menuItem) => {
    const { id, ...menuItemProps } = menuItem;
    return menuItemProps;
  };

  for (const menuItem of menuItems) {
    const itemType = models.itemTypes.find((i) => i.id === menuItem.itemType);
    const existingItemType = existingItemTypes.find((i) => i.apiKey === itemType.apiKey);
    const existingMenuItem = existingMenuItems.find((m) => m.itemType === existingItemType.id);
    const menuItemProps = {
      ...getPropsOfMenuItem(menuItem),
      itemType: existingItemType.id,
    };
    let currentMenuItem = existingMenuItem || menuItem;

    if (existingMenuItem) {
      currentMenuItem = await client.menuItems.update(existingMenuItem.id, menuItemProps);
      existingMenuItems = existingMenuItems.map((m) => (m.id === currentMenuItem ? currentMenuItem : m));
    } else {
      currentMenuItem = await client.menuItems.create(menuItemProps);
      existingMenuItems = [...existingMenuItem, currentMenuItem];
    }
  }

  for (const existingMenuItem of existingMenuItems) {
    const existingItemType = existingItemTypes.find((i) => i.id === existingMenuItem.itemType);
    const itemType = models.itemTypes.find((i) => i.apiKey === existingItemType.apiKey);
    const menuItem = menuItems.find((m) => m.itemType === itemType.id);

    if (!menuItem) {
      await client.menuItems.destroy(menuItem.id);
    }
  }
}

async function reset ({ apiKey }) {
  const client = new datocmsClient.SiteClient(apiKey);
  const items = await client.items.all();
  const menuItems = await client.menuItems.all();

  const deleteItemTypes = async () => {
    console.log('deleting item types...');
    const itemTypes = await client.itemTypes.all();
    return Promise.all(itemTypes.map(async (itemType) => client.itemTypes.destroy(itemType.id)));
  };

  try {
    console.log('deleting menu items...');
    await Promise.all(menuItems.map(async (menuItem) => client.menuItems.destroy(menuItem.id)));
  } catch (e) {
    console.log(e);
  }

  try {
    console.info('deleting items...');
    await Promise.all(items.map(async (item) => client.items.destroy(item.id)));
  } catch (e) {
    console.log(e);
  }

  let errorDeletingItemTypes = false;
  do {
    try {
      await deleteItemTypes();
      errorDeletingItemTypes = false;
    } catch (e) {
      errorDeletingItemTypes = true;
    }
  } while (errorDeletingItemTypes);
}

exports.exportMenu = exportMenu;
exports.exportModels = exportModels;
exports.importMenu = importMenu;
exports.importModels = importModels;
exports.reset = reset;
